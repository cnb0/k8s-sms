apiVersion: v1
kind: ConfigMap
metadata:
  name: api-server-files
  namespace: kube-sms
data:
  server: |
    from flask import Flask, json
    from flask_jwt import JWT, jwt_required, current_identity
    from flask_cors import CORS, cross_origin
    from werkzeug.security import safe_str_cmp
    from mysql.connector import Error
    from datetime import timedelta
    import mysql.connector
    import os

    class User(object):
        def __init__(self, id, username, password):
            self.id = id
            self.username = username
            self.password = password

    if not os.environ.get("USERNAME") or not os.environ.get("PASSWORD"):
        raise RuntimeError('Username and password environment variables must be defined for security access')
    admin = User(1, os.environ.get("USERNAME"), os.environ.get("PASSWORD"))

    def identity(payload):
        return admin

    def authenticate(username, password):
        if safe_str_cmp(admin.password.encode('utf-8'), password.encode('utf-8')):
            return admin

    api = Flask(__name__)
    api.debug = True if os.environ.get("DEBUG") else False
    api.config['SECRET_KEY'] = os.environ.get("JWT_SECRET") if os.environ.get("JWT_SECRET") else 'static-jwt-secret'
    api.config['CORS_HEADERS'] = 'Content-Type'
    api.config['JWT_EXPIRATION_DELTA'] = timedelta(seconds=300)
    cors = CORS(api)
    jwt = JWT(api, authenticate, identity)
    conn = None

    @cross_origin()
    @api.route('/get', methods=['OPTIONS'])
    def getOption():
        return 'OPTIONS'
        
    @cross_origin()
    @api.route('/get', methods=['GET'])
    @jwt_required()
    def get():
        data = {'ingress': False, 'nodes': [], 'links': []}

        db = connect()
        if db == None:
            return json.dumps({"status": False, "message": "Unable to connect to master db"})
            
        cursor = db.cursor()
        cursor.execute("SELECT * FROM node")
        list = cursor.fetchall()
        columns = cursor.description

        for row in list:
            node = associate(row, columns)

            metadata = getMetadata(node)
            services = getService(node)
            trafic = getTrafic(node, services)
            status = getStatus(node, services)

            data['nodes'].append({
                'id': node['id'], 
                'name': node['name'], 
                'disabled': False if 1 == node['active'] else True,
                'services': services, 
                'metadata': metadata,
                'trafic' : trafic,
                'status': status})

        cursor.execute("SELECT * FROM link")
        list = cursor.fetchall()
        columns = cursor.description

        for row in list:
            link = associate(row, columns)
            if int(link['from_node_id']) == 0:
                data['ingress'] = True
            data['links'].append({
                'from': str(link['from_node_id'])+'#'+str(link['from_id']) if int(link['from_node_id']) != 0 else 'ingress', 
                'to': str(link['to_id'])})
                
        return json.dumps(data)

    def getStatus(node, services):
        db = connect()
        cursor = db.cursor()
        inQuery = """SELECT COUNT(*) AS count , 
            SUM(CASE WHEN SUBSTRING(code, 1, 1) = '2' THEN 1 ELSE 0 END) AS 2xx, 
            SUM(CASE WHEN SUBSTRING(code, 1, 1) = '3' THEN 1 ELSE 0 END) AS 3xx,
            SUM(CASE WHEN SUBSTRING(code, 1, 1) = '4' THEN 1 ELSE 0 END) AS 4xx, 
            SUM(CASE WHEN SUBSTRING(code, 1, 1) = '5' THEN 1 ELSE 0 END) AS 5xx
            FROM request WHERE to_id = %s
        """
        cursor.execute(inQuery, (node['id'],))
        row = cursor.fetchone()
        columns = cursor.description
        statusIn = associate(row, columns)

        serviceIds = []
        for service in services:
            serviceIds.append(str(service['id']))
        
        outQuery = """SELECT COUNT(*) AS count , 
            SUM(CASE WHEN SUBSTRING(code, 1, 1) = '2' THEN 1 ELSE 0 END) AS 2xx, 
            SUM(CASE WHEN SUBSTRING(code, 1, 1) = '3' THEN 1 ELSE 0 END) AS 3xx,
            SUM(CASE WHEN SUBSTRING(code, 1, 1) = '4' THEN 1 ELSE 0 END) AS 4xx, 
            SUM(CASE WHEN SUBSTRING(code, 1, 1) = '5' THEN 1 ELSE 0 END) AS 5xx
            FROM request WHERE from_id IN ("""+','.join(serviceIds)+ """)
        """
        cursor.execute(outQuery)
        row = cursor.fetchone()
        columns = cursor.description
        statusOut = associate(row, columns)
        
        inState = {}
        index = ['2xx', '3xx', '4xx', '5xx']
        for column in index:
            inState[column] = round(100 * int(statusIn[column]) / int(statusIn['count'])) if statusIn['count'] and int(statusIn['count']) > 0 else 0
        outState = {}
        for column in index:
            outState[column] = round(100 * int(statusOut[column]) / int(statusOut['count'])) if statusOut['count'] and int(statusOut['count']) > 0 else 0
        return {'in' : inState, 'out': outState} 

    def getTrafic(node, services):
        db = connect()
        cursor = db.cursor()
        cursor.execute("SELECT AVG(request_time) FROM request WHERE to_id = %s", (node['id'],))
        inTime = cursor.fetchone()
        cursor.execute("SELECT AVG(response_time) FROM request WHERE to_id = %s", (node['id'],))
        outTime = cursor.fetchone()
        inQuery = """SELECT COUNT(*) AS count , SUM(CASE WHEN SUBSTRING(code, 1, 1) != '5' THEN 1 ELSE 0 END) 
            AS success, SUM(CASE WHEN SUBSTRING(code, 1, 1) = '5' THEN 1 ELSE 0 END) AS error 
            FROM request WHERE to_id = %s
        """
        cursor.execute(inQuery, (node['id'],))
        row = cursor.fetchone()
        columns = cursor.description
        stateIn = associate(row, columns)

        serviceIds = []
        for service in services:
            serviceIds.append(str(service['id']))

        outQuery = """SELECT COUNT(*) AS count , SUM(CASE WHEN SUBSTRING(code, 1, 1) != '5' THEN 1 ELSE 0 END) 
            AS success, SUM(CASE WHEN SUBSTRING(code, 1, 1) = '5' THEN 1 ELSE 0 END) AS error 
            FROM request WHERE from_id IN (""" + ','.join(serviceIds) +""")
        """
        cursor.execute(outQuery)
        row = cursor.fetchone()
        columns = cursor.description
        stateOut = associate(row, columns)
        return {
            'in' : {
                'time': round(inTime[0], 3), 
                'success': round(100 * int(stateIn['success']) / int(stateIn['count'])) if int(stateIn['count']) > 0 else 0, 
                'error': round(100 * int(stateIn['error']) / int(stateIn['count'])) if int(stateIn['count']) > 0 else 0},
            'out' : {
                'time': round(outTime[0], 3), 
                'success': round(100 * int(stateOut['success']) / int(stateOut['count'])) if int(stateOut['count']) > 0 else 0, 
                'error': round(100 * int(stateOut['error']) / int(stateOut['count'])) if int(stateOut['count']) > 0 else 0}
        } 

    def getService(node):
        db = connect()
        services = []
        cursor = db.cursor()
        cursor.execute("SELECT * FROM registration WHERE groupname = %s", (node['name'],))
        list = cursor.fetchall()
        columns = cursor.description
        for row in list:
            service = associate(row, columns)
            services.append({
                'name': service['service'] if service['service'] else service['pod'] ,
                'id': service['id'],
                'host': service['host'],
                'pod': service['pod'],
                'ip': service['ip'],
                'port': service['port'],
                'namespace': service['namespace'],
                'active' : True if 1 == service['active'] else False
            })
        return services

    def getMetadata(node):
        return [
            {'name': 'Group ID', 'value' : '#'+str(node['id'])},
            {'name': 'Group name', 'value' : node['name']},
            {'name': 'Creation date', 'value' : node['created_at']}
        ]

    def connect():
        global conn
        if conn != None and conn.is_connected():
            return conn
        conn = None
        try:
            conn = mysql.connector.connect(host=os.environ["DB_HOST"], database=os.environ["DB_NAME"], user=os.environ["DB_USER"],password=os.environ["DB_PASSWORD"])
            if conn.is_connected():
                return conn
            return None
        except Error as e:
            return None

    def associate(data, columns):
        row = {}
        for (index,column) in enumerate(data):
            row[columns[index][0]] = column
        return row

    if __name__ == '__main__':
        api.run(host='0.0.0.0')
---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-server
  namespace: kube-sms
spec:
  selector:
    matchLabels:
      run: api
  replicas: 1
  template:
    metadata:
      labels:
        run: api
    spec:
      containers:
      - name: server
        image: python
        command: ['sh', '-c', 'pip install flask Flask-JWT flask_cors mysql.connector && python /var/static/server']
        ports:
          - containerPort: 5000
        volumeMounts:
          - name: static-volume
            mountPath: /var/static
        env:
          - name: DEBUG
            value: "1"
          - name: USERNAME
            value: {{admin-username}}
          - name: PASSWORD
            value: {{admin-password}}
          - name: DB_NAME
            value: logs
          - name: DB_HOST
            value: db-service.kube-sms.svc.cluster.local
          - name: DB_USER
            valueFrom:
              secretKeyRef:
                name: dbsecret
                key: username
          - name: DB_PASSWORD
            valueFrom:
              secretKeyRef:
                name: dbsecret
                key: password
      volumes:
        - name: static-volume
          configMap:
            name: api-server-files
---

apiVersion: v1
kind: Service
metadata:
  name: api-server-service
  namespace: kube-sms
spec:
  ports:
  - name: http
    port: 80
    targetPort: 5000
  selector:
    run: api

---   
apiVersion: v1
kind: Secret
metadata:
  name: sms-tls
  namespace: kube-sms
type: Opaque  
data:
  tls.crt: {{tls-crt}}
  tls.key: {{tls-key}}
type: kubernetes.io/tls

---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
  name: api-server-ingress
  namespace: kube-sms
  labels:
    run: api
spec:
  rules:
    - host: {{host}}
      http:
        paths:
          - backend:
              serviceName: api-server-service
              servicePort: http
            path: /
  tls:
    - hosts:
      - {{host}}
      secretName: sms-tls